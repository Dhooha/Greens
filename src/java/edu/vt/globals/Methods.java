/*
 * Created by Dhoha Abid on 2019.04.10
 * Copyright Â© 2019 Dhoha Abid. All rights reserved. 
 */
package edu.vt.globals;

import java.io.BufferedReader;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.net.URL;
import java.nio.charset.StandardCharsets;
import java.util.Map;
import javax.faces.application.FacesMessage;
import javax.faces.context.FacesContext;

/*
This class is created to provide Convenience Class Methods (typed with the "static" keyword")
for all classes in the project to use. This is in support of the Separation of Concerns software
engineering design principle and it prevents verboseness and cluttering in the code. The class
methods provided herein are called as Methods.methodName in any class in the project.
 */
public final class Methods {

    /*
    Tell JSF that you want to keep the FacesMessage messages in the Flash scope. 
    --------------------------------------------------------------
    *** This is required when you redirect to show a JSF page. ***
    --------------------------------------------------------------
    Redirecting to show a JSF page involves more than one subsequent requests and
    the messages would die from one request to another if not kept in the Flash scope.
    
    You can invoke this method in any class as: Methods.preserveMessages()
     */
    public static void preserveMessages() {
        FacesContext.getCurrentInstance().getExternalContext().getFlash().setKeepMessages(true);
    }

    /*
    We display FacesMessage messages using p:growl in an overlay on all JSF pages by including the 
    content of the growlMessages.xhtml within the editableContent of the siteTemplate.xhtml.
    
    In growlMessages.xhtml, we specify showDetail="false" for the SEVERITY_ERROR messages 
    to prevent duplicate display of the same error message generated by the system. 
    Therefore, you should set messageDetail to "" for the SEVERITY_ERROR messages.
    
    You can invoke this method in any class as follows:

        Methods.showMessage("Information", "messageSummary", "messageDetail");
        Methods.showMessage("Warning", "messageSummary", "messageDetail");
        Methods.showMessage("Error", "messageSummary", "");
        Methods.showMessage("Fatal Error", "messageSummary", "messageDetail");
    
    For exception (ex) errors:
        Methods.showMessage("Fatal Error", "messageSummary", "See: " + ex.getMessage());
     */
    public static void showMessage(String messageType, String messageSummary, String messageDetail) {

        switch (messageType) {
            case "Information":
                FacesMessage infoMessage = new FacesMessage(FacesMessage.SEVERITY_INFO, messageSummary, messageDetail);
                FacesContext.getCurrentInstance().addMessage(null, infoMessage);
                break;
            case "Warning":
                FacesMessage warningMessage = new FacesMessage(FacesMessage.SEVERITY_WARN, messageSummary, messageDetail);
                FacesContext.getCurrentInstance().addMessage(null, warningMessage);
                break;
            case "Error":
                FacesMessage errorMessage = new FacesMessage(FacesMessage.SEVERITY_ERROR, messageSummary, messageDetail);
                FacesContext.getCurrentInstance().addMessage(null, errorMessage);
                break;
            case "Fatal Error":
                FacesMessage fatalErrorMessage = new FacesMessage(FacesMessage.SEVERITY_FATAL, messageSummary, messageDetail);
                FacesContext.getCurrentInstance().addMessage(null, fatalErrorMessage);
                break;
            default:
                System.out.print("Message Type is Out of Range!");
        }
    }

    /*
    Return a mutable Map representing the session scope attributes for the current application.
    You can invoke this method in any class as: Methods.sessionMap()
     */
    public static Map sessionMap() {
        return FacesContext.getCurrentInstance().getExternalContext().getSessionMap();
    }

    /**
     * Return the content of a given Curl as String
     * 
     * @param webServiceCurL to retrieve the JSON data from
     * @return JSON data from the given URL as String
     * @ throw Exception
     */
    public static String readCurlContent(String webServiceCurl) throws Exception {
        //String command = "curl -X GET -H X-Access-Token:__API_EXPLORER_AUTH_KEY__ https://eatstreet.com/publicapi/v1/restaurant/90fd4587554469b1884225aec137a02a83c1200448b8c26e/menu";
        // retrive the data from the API
        Process process = Runtime.getRuntime().exec(webServiceCurl);
//        int exitCode = process.exitValue();
//        if (exitCode != 0){
//            Methods.showMessage("Error", "Something went wrong, the system couldn't get the menu data from eatStreet API", "");
//            return null;
//        }
        
        // read the data into inputStream, then BufferedReader
        InputStream inputStream = process.getInputStream(); 
        BufferedReader  reader = null;
        reader = new BufferedReader(new InputStreamReader(inputStream));
        StringBuilder buffer = new StringBuilder();
        char[] chars = new char[10240];
        int numberOfCharactersRead;
        while((numberOfCharactersRead = reader.read(chars)) != -1){
            buffer.append(chars, 0, numberOfCharactersRead);
        }
        process.destroy();
        return buffer.toString();
        
       
    }
}
